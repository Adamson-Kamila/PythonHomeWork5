## TaskStar1
*Дана последовательность натуральных чисел (одно число в строке), завершающаяся числом 0.
Определите значение второго по величине элемента в этой последовательности, то есть элемента,
который будет наибольшим, если из последовательности удалить наибольший элемент.
В этой задаче нельзя использовать глобальные переменные. Функция получает данные, считывая их с клавиатуры, а не получая их в виде параметра. В программе на языке Python функция возвращает результат в виде кортежа из нескольких чисел и функция вообще не получает никаких параметров. В программе на языке C++ результат записывается в переменные,
которые передаются в функцию по ссылке. Других параметров, кроме как используемых для возврата значения, функция не получает.
Гарантируется, что последовательность содержит хотя бы два числа (кроме нуля).*

 *1 3 5 7 3 6 8 4 3 2 0 -> 7*

 *1 2 3 4 5 6 3 1 2 5 3 -> 5*

> Небольшая ремарка, хорошо, что я решила расписать решение этой задачи с проверкой введения разных по величине чисел. Если бы я этого не сделала, то программа работала бы некорректно.

И так.

 Для решения этой задачи, я создала три переменные, для ввода числа и для сохранения максимального значения и значения второго по величине. То есть с вводом элемента программа будет сравнивать число и помещать его в нужную нам переменную (по аналогии с сортировкой или можно сравнить с переливанием жидкостей из бутылок). И у меня было всего две проверки:
 >  if element > first_max:

 и 

 > if element == 0:

 Этих проверок хватало на то, если вводить числа по порядку, по возрастанию, или по порядку, по убыванию. Ну, или если вводимый element == 0.
 Но если вводить в разной последовательности, например, первому числу автоматически присваивается max, второе число будет больше max, а третье меньше max, но больше числа, находящего в sekond_max, то программа, выдавала второй вводимый элемент, игнорируя при этом третий введенный элемент, например, -> 4, 7, 5, 0 -> 4, а должна была показать 5.
 Поэтому пришлось докрутить еще одну проверку:
 >if element < first_max and element > second_max:

 Кратко пробегусь по решению:

 
У нас есть три переменные:
 > element - вводится с клавиатуры и:

 > second_max и

 >first_max 

 Программа будет действовать следующим образом. В переменных second_max и first_max по дефолту находятся 0. Мы заранее знаем, что первый введенный элемент будет максимальным, пусть это будет цифра 4 и прежде чем мы 4 поместим в переменную first_max нам нужно будет освободить для неё, в first_max, место. 0 из first_max перемещается в  second_max, а 4 отправляется в first_max. Затем, пользователь вводит следующее число, пусть это будет 7. Мы сравниваем, 7 > чем элемент в first_max, да. Поэтому, 4-ку, находящуюся в first_max мы перемещаем в  second_max, а 7 отправляем в first_max. Следующий элемент, например, - 5. 5-ка < чем first_max, но больше чем элемент в second_max. Поэтому, 4 мы убираем из second_max, а помещаем туда 5. Пусть следующее число завершит работу input, введём 0. На выходе мы получим такой результат:
  > (4, 7, 5, 0) -> 5

  Еще один момент, если в писке будут находиться всего два элемента, то есть одно натуральное число, а второе 0, а мы знаем, что 0 будет находиться в переменной second_max и на выходе в консоли мы увидим именно 0, но мы знаем, что 0 - не натуральное число, то для этого случая я использовала тернарный оператора:

  >  return element, second_max if second_max else first_max

  то есть, если список состоит из (8, 0) , то на выходе мы увидим не 0, а first_max, то есть 8.
  
  Для красивого вывода в консоль использовала срезы. 
   


## TaskStar2
*Даны натуральные числа k и s. Определите, сколько существует k-значных натуральных чисел,
сумма цифр которых равна s. Запись натурального числа не может начинаться с цифры 0.
В этой задаче можно использовать цикл для перебора всех цифр, стоящих на какой-либо позиции.*

*3 15 -> 69*
*4 16 -> 564*
*2 3 -> 3*
*6, 40 ->10746*

Для решения этой задачи я создала две функции. 
1-ая функция главная - main. В этой функции находятся: ввод чисел - k и s и вызов второй функции.
2-ая функция - в ней происходят некоторые преобразования числа k.

И так. 
Пользователь ввел числа k и s.

k отвечает у нас за разрядность числа. Например, если k = 3, то это сотни.
Но, мы делаем вид, что этого не знаем, нам нужно написать код, чтобы программа сама определяла разрядность вводимого k.
Поэтому я решила возвести число 10 в степень k-1. Например, k = 3. Следующий шаг - 10 возводим в k-1 (3-1), то есть 10 во 2-ую степень, получаем 100.
Потом, я заполнила список числами равных разряду введенного k, в нашем случае k = 100, поэтому список заполнился числами от 100 (10 ** k-1) до 999 (10 ** k)-1.  Нюанс, числа имели тип str, а не int. ('100', '101', '102', '103',...'999') Для чего?
Для того чтобы когда я запущу цикл for с переборкой элементов в списке, я буду вытаскивать каждое число из списка, разделять его на отдельные элементы, то есть было str (100), а стало int (1, 0, 0) и буду складывать эти элементы между собой, для получения нужного мне результата, а именно сумма должна будет равна введенному s. Я использовала два цикла for для переборки строк в списке и для переборки разбитых строк на элементы.
Также завела переменную для подсчета количества результатов, сколько существует вариантов сложений сумма которых будет равна s.



